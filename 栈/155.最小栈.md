# 1.辅助栈

**核心**:要求在常数时间内获得栈中最小值，因此不能在调用`getMin()`时再去寻找最小值，需要在每次出入栈时就能确定栈中的最小值

- 额外使用一个“最小辅助栈”`min_sta`,其中存放每次主栈入栈后其中的最小值（辅助栈顶即为此时主栈中最小值）
- 
*过程*
- 将元素压入主栈，此时判断该元素与`min_sta.top()`的大小关系
- 若比辅助栈顶大则不压入辅助栈，而是将辅助栈原栈顶再入栈依次（表示此次操作后，最小值仍是原最小值）
- 若比辅助栈顶小则压入辅助栈（表示此次操作后，最小值为辅助栈顶）
- （实际上，辅助栈中存放的是对应每次操作后的最小值

```C++
class MinStack
{
private:
    stack<int> sta;
    stack<int> min_sta;

public:
    /** initialize your data structure here. */
    MinStack()
    {
        min_sta.push(INT_MAX);//先入栈最大整数使得第一个元素可以入栈
    }

    void push(int val)
    {
        sta.push(val);
        min_sta.push(min(min_sta.top(), val));
    }

    void pop()
    {
        sta.pop();
        min_sta.pop();
    }

    int top()
    {
        return sta.top();
    }

    int getMin()
    {
        return min_sta.top();
    }
};
```
- 时间复杂度: O(1),对于每次操作而言是1
- 空间复杂度: O(2n)
