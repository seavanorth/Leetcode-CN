都很简单，不解释了
相关API：[C++官方文档](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)
# 1.原地判断
```C++ []
class Solution
{
public:
    bool isPalindrome(string s)
    {
        int f = 0, r = s.size() - 1;
        while (f < r)
        {
            while (f < r && !isalnum(s[f]))
                f++;
            while (f < r && !isalnum(s[r]))
                r--;
            if (f < r)
            {
                if (toupper(s[f]) != toupper(s[r]))
                    return false;
                f++;
                r--;
            }
        }
        return true;
    }
};
```
>- 时间复杂度: O()
>- 空间复杂度: O()

***

# 2.先筛选后判断
## 2.1翻转判断
```C++ []
class Solution
{
public:
    bool isPalindrome(string s)
    {
        string tmp;
        int n = s.size();
        for (int i = 0; i < n; i++)
            if (isalnum(s[i]))
                tmp += toupper(s[i]);
        string tmprev(tmp.rbegin(), tmp.rend());
        return tmp == tmprev;
    }
};
```
```Python3 []
class Solution:
    def isPalindrome(self, s: str) -> bool:
        tmp = "".join(ch.upper() for ch in s if ch.isalnum())
        return tmp == tmp[::-1]
```
## 2.2双指针判断
```C++ []
class Solution
{
public:
    bool isPalindrome(string s)
    {
        string tmp;
        int n = s.size();
        for (int i = 0; i < n; i++)
            if (isalnum(s[i]))
                tmp += toupper(s[i]);
        int f = 0, r = tmp.size() - 1;
        while (f < r)
        {
            if (tmp[f] != tmp[r])
            return false;
            f++;
            r--;
        }
        return true;
    }
};
```
```Python3 []
class Solution:
    def isPalindrome(self, s: str) -> bool:
        tmp = "".join(ch.lower() for ch in s if ch.isalnum())
        f, r = 0, len(tmp) - 1
        while f < r:
            if tmp[f] != tmp[r]:
                return False
            f += 1
            r -= 1
        return True
```
>- 时间复杂度: O()
>- 空间复杂度: O()
