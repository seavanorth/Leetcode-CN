[27.移除元素](https://leetcode-cn.com/problems/remove-element/)

***

*该题与*[26. 删除有序数组中的重复项](/problems/remove-duplicates-from-sorted-array/)*类似*

# 1.双指针
- `fast`指向当前要判断的元素，`slow`指向下个要赋值的位置
- 若`nums[fast] == val`,则`slow`不动，`fast++`
- 若`nums[slow] != val`,则将`nums[fast]`赋给`nums[slow]`
```C++ []
class Solution
{
public:
    int removeElement(vector<int> &nums, int val)
    {
        int n = nums.size();
        int slow = 0;
        for (int fast = 0; fast < n; fast++)
        {
            if (nums[fast] != val)
            {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }
};
```
```Python3 []
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        slow = fast = 0
        while fast < len(nums):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
            #elif nums[fast] == val:
            fast += 1
        return slow
```
- 时间复杂度: O(n),n为原数组长度,至多需遍历原数组2次
- 空间复杂度: O(1),常数空间保存若干变量

# 2.双指针小优化
**核心**:题目对返回数组只有长度要求，没有顺序要求
- 当出现目标删除元素位于数组开头，如`[3,2,1,4,5] val = 3`时，为删除第一个元素，需要将后四个元素依次往前移一位
- 此时从开头和尾部开始遍历可优化
```C++ []
class Solution
{
public:
    int removeElement(vector<int> &nums, int val)
    {
        int left = 0, right = nums.size();
        //因为下面while循环结束条件是“left = right”，若初始化right = nums.size() - 1
        //则若出现最后一次nums[left] = nums[right - 1]结束赋值后
        //则无法进入下次循环判断该次赋值是否有效(即nums[right] == val ?)
        while (left < right)
        {
            if (nums[left] == val)
            {
                nums[left] = nums[right - 1];
                right--;
            }
            //nums[high - 1]此时也可能 == val，故low不直接自增，需进入下次循环判断
            else
                left++;
        }
        return left;
    }
};
```
```Python3 []
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        low, high = 0, len(nums)
        while low < high:
            if nums[low] == val:
                nums[low] = nums[high - 1]
                high -= 1
            #nums[high - 1]此时也可能 == val，故low不直接自增，需进入下次循环判断
            else:
                low += 1
        return low
```
- 时间复杂度: O(n),n为原数组长度,至多只需遍历该数组一次
- 空间复杂度: O(1),常数空间保存若干变量

# 3.删除重复元素通解
实际与解法2双指针优化过程相同，只是代码简洁了些
```
class Solution
{
public:
    int removeElement(vector<int> &nums, int val)
    {
        int j = nums.size() - 1;
        for (int i = 0; i <= j; i++)
            if (nums[i] == val)
                nums[i--] = nums[j--];
        return j + 1;
    }
};
```
