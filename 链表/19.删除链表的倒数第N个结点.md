```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
```

***
 
# 1.辅助数组计数

- 可使用`vector`，遍历链表加入数组，得到长度
- 通过数组下标直接访问到待删除结点的前一结点
- **注意**:若要删除的是头结点，则不要通过下标访问，因为无下标为`-1`的元素，直接返回`head->next`即可

 ```cpp
 class Solution
{
public:
    ListNode *removeNthFromEnd(ListNode *head, int n)
    {
        ListNode *trav = head;
        vector<ListNode *> table;
        while (trav != nullptr)
        {
            table.push_back(trav);
            trav = trav->next;
        }
        int index = table.size() - n - 1;
        if (index < 0)
            return head->next;
        trav = table[index];
        trav->next = trav->next->next;
        //ListNode *del = trav->next;
        //delete del;
        return head;
    }
};
 ```
 
- 时间复杂度:O(N),N为链表结点数
- 空间复杂度:O(N),N为链表结点数，主要为数组开销

***
# 2.遍历计数

- 使用额外变量`size`储存链表长度
- 遍历得到链表长度
- 通过`n`和`size`计算得到从头结点到待删除结点所需移动步数，移动到位并删除
- **注意**:若要删除的是头结点，则不要通过下标访问，因为无下标为`-1`的元素，直接返回`head->next`即可
```cpp
class Solution
{
public:
    ListNode *removeNthFromEnd(ListNode *head, int n)
    {
        ListNode *fast = head;
        int size = 0;
        while (fast != nullptr)
        {
            fast = fast->next;
            ++size;
        }
        int index = size - n - 1; //要删除结点的前一个结点
        if (index < 0)
            return head->next;
        fast = head;
        while (index > 0) //index为slow移动次数
        {
            fast = fast->next;
            index--;
        }
        fast->next = fast->next->next;
        return head;
    }
};
```
- 时间复杂度:O(N + N - n),N为结点数，移动到倒数第`n`个结点需`N - n`
- 空间复杂度:O(1),只使用了额外
