# 1.层序遍历1(广度优先)
```cpp
class Solution
{
public:
    Node *connect(Node *root)
    {
        if (root == nullptr)
            return root;
        queue<Node *> que;
        que.push(root);
        while (!que.empty())
        {
            int curLevelSize = que.size();
            for (int i = 0; i < curLevelSize; i++)
            {
                Node *trav = que.front();
                que.pop();
                //不可用if(!que.empty())
                if (i < curLevelSize - 1) //判断该层已处理节点个数，避免将该层与下一层关联
                    trav->next = que.front();
                if (trav->left)
                    que.push(trav->left);
                if (trav->right)
                    que.push(trav->right);
            }
        }
        return root;
    }
};
```
- 时间复杂度:O(N), n为完美二叉树节点数, 每个节点都会被访问一次;
- 空间复杂度:O(N), n为完美二叉树节点数

***

# 2.层序遍历2(利用)
```cpp
class Solution
{
public:
    Node *connect(Node *root)
    {
        if (root == nullptr)
            return root;
        Node *leftmost = root;
        while (leftmost->left != nullptr)
        {
            Node *traveHead = leftmost;//从最左节点开始
            //循环将该层节点作为下一层的父节点进行相关操作
            while (traveHead != nullptr)//traveHead == nullptr时,即移动到该层rightmost,停止
            {
                //connection1:一个父节点下得左右节点连接
                traveHead->left->next = traveHead->right;
                //connnection:相邻父节点间，left父节点的right与rightchild父节点的leftchild连接
                if (traveHead->next != nullptr)
                {
                    traveHead->right->next=traveHead->next->left;
                }
                traveHead = traveHead->next;//移动到下一组左右父节点
            }
            leftmost = leftmost->left;//移动到下一层的最左节点
        }
        return root;
    }
};
```
- 时间复杂度:O(N),N为完美二叉树节点数,每个节点都会被访问一次
- 空间复杂度:O(1),无需额外储存空间
